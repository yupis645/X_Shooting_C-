//
//#include "Ground_Enemy.h"
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//														/*地上敵の初期化*/
////===========================================================
////					初期化
////
//// 敵の数だけ初期化する
////===========================================================
//
//void G_Enemy_Init(ENEMY* _e) {
//	for (int i = 0; i < MAX_ENEMY; i++) {
//		memcpy(&_e->enemy[i], &E_Init, sizeof(ENEMY_ST));		//データを初期化
//	}
//	_e->count = 0;
//	_e->pop_F = false;
//}
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//														/*地上敵の生成*/
//
////======================================================================================================================
////					敵の生成
////
//// 引数は敵の番号、バックマップにおける座標,配置するバックマップナンバー、ワールド座標見た地上敵の中心座標
//// ・numberが100を超えている場合は百の位の値をtypeとして受け取り、十と一の位の値をnumberとして取得する
//// ・取得したnumberを元に種類ごとの初期ステータスを代入する
//// ・引数で受け取ったデータをステータスに代入していく
//// ・typeによって得点が違う場合はここで得点を補正する
//// ・グラフィックデータの代入
//// ・当たり判定と画像の位置を同期させる
//// ・作成したステータスを返り値とて返す
////======================================================================================================================
//void G_Enemy_Create(ENEMY* _e,int number, int axis_point, int backmap_num, float axis_x)
//{
//
//	int EmptyNum = SetEmptyNum(*_e);
//	if (EmptyNum == 99) { return; }		//エラー(ENEMYの中で1体もframe_inがfalse出なかった場合)
//
//	_e->enemy[EmptyNum] = E_Init;
//
//	int type = 0;
//
//	//[セーフティ] : ナンバーが0〜10でなければ処理を止める
//	if (number < 0 && number > 10) {
//		_e->enemy[EmptyNum].frame_in = false;				//frameinをfalseにしておけば空いているステータスと認識される
//		return;								//処理を止める
//	}
//
//	//挙動によってタイプ分けをする(裏マップでの百の位はタイプ番号のことを指す。例)100 = typeは1でnumberは0の敵 => トーロイドのタイプ1(弾を発射しない))
//	if (number >= 100) {								//裏マップで100を超えていたら
//		type = number / 100;								//百の位をタイプとして代入
//		number = number - (100 * type);		//敵の番号は裏マップ番号から100 * タイプ番号を引いた値 
//	}
//
//
//	_e->enemy[EmptyNum] = G_enemyData[number % 50];
//	//memcpy(&_e, &G_enemyData[number % 50], sizeof(ENEMY_ST));		//敵の番号に応じた初期ステータスを取得
//
//	//[セーフティ] : typeが初期値以上の値が出ている場合は0(通常動作)のtypeとして生成する
//	if (_e->enemy[EmptyNum].type < type) { type = 0; }
//
//	_e->enemy[EmptyNum].type = type;								//タイプの移植
//	_e->enemy[EmptyNum].back_coord = axis_point;				//裏マップにおける座標を記憶する
//	_e->enemy[EmptyNum].back_num = backmap_num;			//裏マップ番号を記憶する
//	_e->enemy[EmptyNum].center_x = axis_x;				//敵の中心座標を設定[(0座標からの距離) + 敵の大きさの半分]
//
//	_e->enemy[EmptyNum].center_y = -(CHIP_SIZE / 2);	//ウィンドウの一番上よりキャラクターのサイズの半分高い位置にセンター座標を設定する(画面外で出現させる)
//
//	//Typeによる得点の変化
//
//	if (_e->enemy[EmptyNum].number == 55) {
//		if (_e->enemy[EmptyNum].type <= 4) {
//			_e->enemy[EmptyNum].points += _e->enemy[EmptyNum].points * _e->enemy[EmptyNum].type;							//タイプ4以下は基本点200点からタイプが1上がるたびに+200点
//
//		}
//		else if (_e->enemy[EmptyNum].type <= 7) {
//			_e->enemy[EmptyNum].points = (_e->enemy[EmptyNum].points + (100 * (_e->enemy[EmptyNum].type - 4))) * 5;		//タイプ4以下は基本点200点からタイプが1上がるたびに+200点
//
//		}
//		else if (_e->enemy[EmptyNum].type == 8) {
//			_e->enemy[EmptyNum].points = 10000;
//
//		}
//	}
//
//
//	/*グラフィックの設定*/
//	LoadDivBmp(PngData.G_Enemy,					//画像を代入する
//		0, 0, _e->enemy[EmptyNum].pic_size, _e->enemy[EmptyNum].pic_size, G_ENEMY_PIC_LINE, 9, _e->enemy[EmptyNum].pic);
//
//
//	/*中心座標から'当たり判定'と'画像'の左上と右下の座標*/
//	Hitbox_Sync(&_e->enemy[EmptyNum].hitbox, _e->enemy[EmptyNum].hitbox_size,				//RECT:当たり判定 , int:当たり判定の中心座標から見たサイズ
//		&_e->enemy[EmptyNum].center_x, &_e->enemy[EmptyNum].center_y,						//float:中心座標(X) , 中心座標(Y)
//		&_e->enemy[EmptyNum].pic_x, &_e->enemy[EmptyNum].pic_y, _e->enemy[EmptyNum].pic_size);	//int:画像左上のx座標 , 画像左上のy座標 , int:画像のサイズ
//
//}
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//														/*地上敵の情報更新*/
//
////======================================================================================================================
////					更新
////
//// 敵の最大数までループで画面内にいるかを判定し、画面内にいるのなら軸の移動やヒット判定などの処理をする
//// ・エネミー番号に応じた移動や攻撃などを行う
//// ・地上物は全てスクロール速度と同じY軸移動をする
//// ・当たり判定の同期と画面外に出ていないかのチェック
//// ・1体の敵が独自に持つ内部タイマーを進める
//// ・ボムに対するヒット判定をする。ヒットしていた場合は撃破処理とスコアの加算、一部の敵は独自の挙動をする
////		この処理を最大数までループする
////======================================================================================================================
//
//void G_Enemy_Update(PLAYER* _p, ENEMY* _e, ENEMY_SHOT* _s, SCENE* _sc, MAP* _m, EFFECT* _ef) {
//
//	for (int r = 0; r < MAX_ENEMY; r++) {
//		if (_e->enemy[r].frame_in == true) {
//		
//			/*エネミーの行動*/
//			G_Enemy_Moving(_p, &_e->enemy[r], _s, _sc->frame_count, _m);		//敵の行動(numberによって異なる挙動をする)
//
//
//			/*地上物共通のY軸移動*/
//			if (_sc->frame_count % SCROLL_SPEED == 0) {
//				_e->enemy[r].center_y++;
//			}
//
//			/*当たり判定の同期*/
//			Hitbox_Sync(&_e->enemy[r].hitbox, _e->enemy[r].hitbox_size,				//RECT:当たり判定 , int:当たり判定の中心座標から見たサイズ
//				&_e->enemy[r].center_x, &_e->enemy[r].center_y,						//float:中心座標(X) , 中心座標(Y)
//				&_e->enemy[r].pic_x, &_e->enemy[r].pic_y, _e->enemy[r].pic_size);	//int:画像左上のx座標 , 画像左上のy座標 , int:画像のサイズ
//
//			/*座標が画面外に出た場合の座標の初期化*/
//			if (_e->enemy[r].center_y > 0) {
//				if (!Hit_box(_e->enemy[r].hitbox, winView))	{			//当たり判定とウィンドウサイズのRECTと重なっていない = 画面外 なら 
//					memcpy(&_e->enemy[r], &E_Init, sizeof(ENEMY_ST));	//データを初期化する
//					_e->count--;										
//				}
//			}
//		}
//
//		//撃破判定が出ていない間
//		if (_e->enemy[r].hit == false) {
//			_e->enemy[r].ac_count++;			//1フレームごとに加算される
//		}
//		//爆発のスプライトの表示時間
//		else {
//			if (_sc->frame_count % 10 == 0) {
//				_e->enemy[r].ac_count++;		//10フレームごとに加算される(爆発アニメーションの更新を10フレームに1度にするため)
//			}
//			continue;		//被弾判定の処理には行かず、次の番号の処理へ
//		}
//
//
//		/*ボムに対する被弾判定*/
//		if (_p->bom.bomber == true) {			//
//			_e->enemy[r].hit = Hit_box(_p->bom.hitbox, _e->enemy[r].hitbox);		//自機のショットに対する被弾判定
//			if (_e->enemy[r].hit == true) {		//被弾判定がtrueになったら
//				_e->enemy[r].ac_count = 0;			//カウント変数を初期化(爆発エフェクトの表示時間に使うため)
//				state.score += _e->enemy[r].points;	//エネミーの持つ点数をスコアに加算する
//
//				/*破壊したのがボザログラムなら周りのログラムも自壊させる*/
//				if (_e->enemy[r].number == 56) {
//					int count = 0;			//ログラムが何個残っていたかを確かめる
//					for (int r2 = 0; r2 < MAX_ENEMY; r2++) {							//出現している地上の敵を全て見る
//						if (_e->enemy[r2].number == 52 && _e->enemy[r2].type >= 1) {	//typeが1以上のログラムを見つける
//							if (_e->enemy[r2].hit == false) {							//もしまだ壊されていなかったら
//								count++;												//カウントを勧める
//								_e->enemy[r2].hit = true;								//破壊フラグをONにする
//								_e->enemy[r2].ac_count = 0;								//カウント変数を初期化
//							}
//						}
//					}
//					if (count == 4) {
//						state.score += 1400;	//自壊したログラムの数が４つだったら2000点をスコアに入れる
//					}
//				}
//				//破壊したのがゾルバグなら
//				else if (_e->enemy[r].number == 51) {	
//				A_Date_Table.Lv--;								//出現レベルを下げる
//				REPEAT(A_Date_Table.Lv, 0, MAX_LEVEL - 1);		//lvが上下の限度値を超えた場合、最少もしくは最大値に合わせる
//				}
//				break;
//			}
//
//		}
//
//	}
//}
//
//
//
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//																	/*地上の敵のスプライトを表示する*/
//
////======================================================================================================================
////					更新
////
//// 敵の最大数までループで画面内にいるかを判定し、描画を行う。
//// 撃破されてから60フレーム以内は爆発エフェクトも表示する
////======================================================================================================================
//
//void G_Enemy_Draw(ENEMY* _e, EFFECT* _ef) {
//
//	for (int r = 0; r < MAX_ENEMY; r++) {
//		if (_e->enemy[r].frame_in == true) {
//			//テクスチャの描写
//			DrawBmp(_e->enemy[r].pic_x, _e->enemy[r].pic_y, _e->enemy[r].pic[_e->enemy[r].anim]);
//
//			//爆発エフェクト
//			if (_e->enemy[r].hit == true && _e->enemy[r].ac_count < 6) {
//				DrawBmp(_e->enemy[r].hitbox.left - 5, _e->enemy[r].hitbox.top - 5, _ef->DieEffect[_e->enemy[r].ac_count]);
//			}
//		}
//	}
//}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//																	/*地上の敵の動き*/
//
//
////======================================================================================================================
////							地上敵それぞれの動き
////
//// 番号に応じた座標移動や攻撃をする
//// 詳細はそれぞれの関数で
////======================================================================================================================
//void G_Enemy_Moving(PLAYER* _p, ENEMY_ST* _e, ENEMY_SHOT* _s, int _frame, MAP* _m) {
//	/*地上敵*/
//// 0:バーラ, 1:ゾルバグ , 2:ログラム , 3ドモグラム , 4:デローダ , 5:グロプター , 6ソル ||| 7:ガルバーラ , 8:ボザログラム , 9::ガルデロータ , 10:ドモグラム
//
//	//番号が57以下は撃破されたときの動きは共通でanimを0にしたら処理を終える
//	if (_e->hit == true && _e->number < 57) { _e->anim = 0; return; }
//
//
//	if (_e->number == 50) {		BARRA();	 }
//	if (_e->number == 51) {		ZOLBAK(_e, _frame);	}
//	if (_e->number == 52) {		LOGRAM(_p->center_x, _p->center_y, _e, _s, _frame);	}
//	if (_e->number == 53) {		DOMOGRAM(_p->center_x, _p->center_y, _e, _s, _m, _frame);	}
//	if (_e->number == 54) {		DEROTA(_p->center_x, _p->center_y, _e, _s, _frame);	}
//	if (_e->number == 55) {		GROBDA(_p->center_x, _p->center_y, _p->bom, _p->sight_hitbox, _e, _frame);			}
//	if (_e->number == 56) {		BOZALOGRAM();	}
//	if (_e->number == 57) {		SOL(_e, _frame);	}
//	if (_e->number == 58) {		GARUBARRA(_e);	}
//	if (_e->number == 59) {		GARUDEROTA(_p->center_x, _p->center_y, _e, _s, _frame);	}
//	
//	//if (_e->number == 60);	//ボスの砲台。Boss.cppに記載
//	//if (_e->number == 61);	//ボスのコア。Boss.cppに記載
//
//	if (_e->number == 62) {		SPECIALFLAG(_p->hitbox, _p->sight_hitbox, &_p->lookon, _e);	}
//}
//
////======================================================================================================================
////							アニメーションの更新
////
//// anim番号を加算させたり減算したりさせる事でアニメーションを滑らかにしている
//// ・anim番号の増減(_e->dirの正負によって決まる)
//// ・最大値に達したら次からanim番号は減算させる
//// ・最小値に達したら次からanim番号は加算させる
////======================================================================================================================
//void G_Enemy_Anim(ENEMY_ST* _e, int _frame, int cycle)
//{
//	int number = _e->number - 50;
//
//	if (_frame % cycle == 0) {
//		_e->anim += 1 * _e->dir;
//	}
//
//
//	/*地上物はdirによってアニメーションを逆再生にする*/
//
//	if (_e->anim >= _e->anim_sum + (G_ENEMY_PIC_LINE * number) - 1) {
//		_e->dir = -1;
//	}
//	else if (_e->anim <= number * G_ENEMY_PIC_LINE) {
//		_e->dir = 1;
//	}
//
//}
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//																	/*地上敵の固有処理*/
//
//
////=======================================================================
////						バーラ[ピラミット]
////
//// 何の動作もしないにぎやかし
////=======================================================================
//void BARRA() {	/*動作ナシ*/ }
//
////=======================================================================
////						ゾルバク[四隅が点滅している丸い建物]
////
//// これ自体に動作はないが、撃破時にLvが下がる
//// この関数は動作を設定する場所なのでLvを下げる処理は被弾処理の直後
//// 
//// ・アニメーションを更新する
////=======================================================================
//void ZOLBAK(ENEMY_ST* _e, int _frame) {
//	G_Enemy_Anim(_e, _frame, 10);		//アニメーションの更新
//	
//}
//
////===============================================================================================
////						ログラム[固定砲台]
////
//// 一定間隔でプレイヤーに向かって射撃する。
////		Y座標が4/6(画面の中央より少し下)になると射撃をしなくなる
//// 
//// ・pat 0:待機状態。アニメーションも更新も無効化する
//// ・pat 1:射撃態勢。アニメーション番号が最大に達したときに射撃をする。
//// ・pat 2:アニメーションが初期値に戻るとpat 0に戻る
//// 
//// ・type 0 : 通常
//// ・type 1〜4 : ボザログラムの周りにいるログラム。挙動は同じだがボザログラムが破壊されると自壊する
////===============================================================================================
//void LOGRAM(float px, float py, ENEMY_ST* _e, ENEMY_SHOT* _s, int _frame) {
//
//	int number = _e->number - 50;		//アニメーションに
//
//	//敵弾の発射が可能かの判定
//	bool shot_ok = true;				//trueなら弾の発射ができる
//	int shotnum = E_shotGetEmptyNum(*_s);		//フラグの立っていない敵弾を探す
//	if (shotnum == 99) { shot_ok = false; }	//sが99 -> 弾の上限が超えているため弾が発射できないようにする
//
//	G_Enemy_Anim(_e, _frame, 7);		//アニメーションの更新
//
//	switch (_e->pat) {
//	//パターン1:待機状態
//	case 0:
//		_e->anim = G_ENEMY_PIC_LINE * number;		//アニメーション固定
//		if (_e->center_y < (SRN_H / 6) * 4) {			//画面の4/6を超えると弾を発射しなくなる
//			if (rand() % 500 == 0) {					//内部カウントが500を超えるたびに
//				_e->pat = 1;									//弾の発射体制へ移行
//			}
//		}
//		break;
//
//	//パターン2:自機への射撃
//	case 1:
//		if (_e->anim == G_ENEMY_PIC_LINE * number + _e->anim_sum - 1) {								//animが発射アニメーションの番号になったら
//			if (shot_ok) {
//				E_Shot_Create(_s, px, py, _e->center_x, _e->center_y, 0);		//自機に向かって弾を発射する
//			}
//			_e->pat = 2;					//次のパターンへ移行する
//		}
//		break;
//	//パターン3:アニメーションを待機状態へ移行
//	case 2:
//		if (_e->anim == G_ENEMY_PIC_LINE * number) {								//待機状態まで戻ったら
//			_e->pat = 0;
//			_e->ac_count = 0;				//パターン番号とタイマーを初期化する
//		}
//		break;
//	}
//}
//
////===============================================================================================
////						ドモログラム[移動砲台]
////
//// 自分の周囲 9つ のバックマップのチップ番号を調べ、特定の値の方向に移動する。
////		チップ番号 20:その方向に向かって進む		7 8 9	
////				   21:進行方向を反転する			4 5 6	←周囲 9 マス(5が現在位置)
////	探索する順番は7〜9,4〜6,1〜3					1 2 3
//// 検索時に2つチップ番号があっても探索して一番最初に見つけた方向に向かう
//// そのため自分が踏んだチップは全て -1 (何もなし)に変化させる
//// 周囲に 20,21のチップがなければ現在の方向に直進する
//// 
//// ・pat 0:待機状態。アニメーションも更新も無効化する
//// ・pat 1:射撃態勢。アニメーション番号が最大に達したときに射撃をする。
//// ・pat 2:アニメーションが初期値に戻るとpat 0に戻る
////===============================================================================================
//void DOMOGRAM(float px, float py, ENEMY_ST* _e, ENEMY_SHOT* _s,MAP* _m, int _frame) {
//
//	int number = _e->number - 50;
//
//	//敵弾の発射が可能かの判定
//	bool shot_ok = true;				//trueなら弾の発射ができる
//	int shotnum = E_shotGetEmptyNum(*_s);		//フラグの立っていない敵弾を探す
//	if (shotnum == 99) { shot_ok = false; }	//sが99 -> 弾の上限が超えているため弾が発射できないようにする
//
//	//行動パターン
//	if (_e->type == 0) {
//		AroundSearch(_e, _m, 50);		//行動パターン 50:裏マップの'1'にそって移動
//	}
//	else if (_e->type == 1) {
//		AroundSearch(_e, _m, 51);		//行動パターン 50:裏マップの'1'にそって移動
//	}
//
//	G_Enemy_Anim(_e, _frame, 10);		//アニメーションの更新
//	switch (_e->pat) {
//	//パターン1:待機状態
//	case 0:
//		_e->anim = G_ENEMY_PIC_LINE * number;		//アニメーション固定
//		if (_e->ac_count % 200 == 0) {
//			_e->pat = 1;							//発射体制へ移行
//		}
//		break;
//	//パターン2:自機への射撃
//	case 1:
//		if (_e->anim == G_ENEMY_PIC_LINE * number + _e->anim_sum - 1) {								//animが発射アニメーションの番号になったら
//			if (shot_ok) {
//				E_Shot_Create(_s, px, py, _e->center_x, _e->center_y, 0);		//自機に向かって弾を発射する
//			}
//			_e->pat = 2;					//次のパターンへ移行する
//			_e->dir = -1;
//		}
//		break;
//	//パターン3:アニメーションを待機状態へ移行
//	case 2:
//		if (_e->anim == G_ENEMY_PIC_LINE * number) {								//待機状態まで戻ったら
//			_e->pat = 0;
//			_e->ac_count = 0;				//パターン番号とタイマーを初期化する
//		}
//		break;
//	}
//	
//}
//
////===============================================================================================
////						デローダ[連射する固定砲台]
////
//// かなり速い間隔で射撃する砲台。画面の4/6を超えると弾を発射しなくなる
//// ・一定間隔で射撃する
////===============================================================================================
//void DEROTA(float px, float py, ENEMY_ST* _e, ENEMY_SHOT* _s, int _frame) {
//
//	int number = _e->number - 50;
//
//	//敵弾の発射が可能かの判定
//	bool shot_ok = true;				//trueなら弾の発射ができる
//	int shotnum = E_shotGetEmptyNum(*_s);		//フラグの立っていない敵弾を探す
//	if (shotnum == 99) { shot_ok = false; }	//sが99 -> 弾の上限が超えているため弾が発射できないようにする
//
//	G_Enemy_Anim(_e, _frame, 10);				//アニメーションの更新
//
//	if (_e->center_y < (SRN_H / 6) * 4) {			//画面の4/6を超えると弾を発射しなくなる
//		if (_frame % 60 == 0) {						//1/60の間隔で射撃をする
//			if (shot_ok) {
//				 E_Shot_Create(_s, px,py, _e->center_x, _e->center_y, 0);		//自機に向かって弾を発射する
//			}
//		}
//	}
//}
//
////===============================================================================================
////						グロプター[移動するだけの戦車]
////
//// 置物…ではなく8つの行動パターンをもつ戦車。攻撃はしない
//// ・type 0:動かない
//// ・type 1:画面の下に向けて直進
//// ・type 2:出現時は停止。照準器と当たり判定が重なると下方向に移動を始める
//// ・type 3:出現時は停止。ボムの射程内でボムを撃つと「前進」。ボムが画面内からなくなると停止
//// ・type 4:下方向に直進。照準器と当たり判定が重なると停止。外れると再度動き出す
//// ・type 5:出現時は停止、ボムの射程内でボムを撃つと「後進」。ボムが画面内からなくなると停止
//// ・type 6:下方向に直進。照準器と当たり判定が重なるとダッシュし、外れると通常速度に戻る
//// ・type 7:下方向に直進。ボムの射程内でボムを撃つと「後進」。ボムが画面内からなくなると停止
//// ・type 8:出現時は停止。ボムの射程内でボムを撃つとダッシュし、外れると再び停止する
////===============================================================================================
//void GROBDA(float px, float py, P_BOM_ST _pb, RECT sight_hitbox, ENEMY_ST* _e, int _frame) {
//
//	int speed_ratio = 4;				//加速時の速度
//	float O_speed = _e->speed;			//元の速度を記憶しておく(加速した後に戻すため)
//	float y_range = ABS(_e->center_y - _pb.center_y);	//ボムとの距離(Y軸の絶対値)
//	float x_range = ABS(_e->center_x - _pb.center_x);	//ボムとの距離(X軸の絶対値)
//	bool lookon = Hit_box(sight_hitbox, _e->hitbox);	//照準器がグロプターの当たり判定と重なっているかの判定
//
//	switch (_e->type) {
//		//常に停止
//	case 0:
//		break;
//		//常に前進
//	case 1:
//		G_Enemy_Anim(_e, _frame, 3);
//		Enemy_Patterns(_e, 3);					//行動パターン 3:前進
//
//		break;
//		//出現時は停止状態。自機の照準が当たると前進を開始する
//	case 2:
//		if (lookon == true) {						//照準器と重なると
//			_e->pat = 1;							//行動パターンを変更
//		}
//		if (_e->pat == 1) {							//パターン変更後は常に前進する
//			G_Enemy_Anim(_e, _frame, 3);
//			Enemy_Patterns(_e, 3);				//行動パターン 3:前進
//		}
//		break;
//		//出現時は停止状態。ボムに反応して前進し、再び停止
//	case 3:
//		if (_e->pat == 0) {
//			if (_pb.F == true && y_range <= BOM_ST && x_range <= CHIP_SIZE) {		//ボム発射フラグON & ボムの射程距離内にいる & ボムとのX軸の距離がチップサイズ(32)以内にある
//				_e->pat = 1;						//パターン変更
//			}
//		}
//		if (_e->pat == 1) {
//			G_Enemy_Anim(_e, _frame, 3);
//			Enemy_Patterns(_e,  3);				//行動パターン 3:前進
//			if (_pb.F == false) {				
//				_e->pat = 0;						//ボムのフラグが消えると停止パターンに戻る
//			}
//		}
//		break;
//		//常に前進し、照準に反応して停止、照準が外れたら再び前進
//	case 4:
//		if (!lookon) {								//照準器と重なっていないなら前進
//			G_Enemy_Anim(_e, _frame, 3);
//			Enemy_Patterns(_e,  3);				//行動パターン 3:前進
//		}
//		break;
//		//常に停止し、ブラスターに反応して後退し、再び停止
//	case 5:
//		if (_e->pat == 0) {
//			if (_pb.F == true && y_range <= BOM_ST && x_range <= CHIP_SIZE) {//ボム発射フラグON & ボムの射程距離内にいる & ボムとのX軸の距離がチップサイズ(32)以内にある
//				_e->pat = 1;						//パターンの変更
//			}
//		}
//		if (_e->pat == 1) {
//			G_Enemy_Anim(_e, _frame, 3);
//			_e->center_y -= (float)_e->speed;		//Y軸の移動
//			if (_pb.F == false) {				
//				_e->pat = 0;						//ボムのフラグが消えると停止パターンに戻る
//			}
//		}
//		break;
//		//前進し、照準に反応してダッシュし、再び前進
//	case 6:
//		if (lookon) {							//照準器が重なっている場合
//			_e->speed *= speed_ratio;			//ダッシュする
//		}
//		G_Enemy_Anim(_e, _frame, 3);
//		Enemy_Patterns(_e,  3);				//行動パターン 3:前進
//
//		_e->speed = O_speed;					//スピードを戻す
//		break;
//		//前進し、ブラスターに反応して後退し、再び前進(2,500点)
//	case 7:
//		if (_e->pat == 0) {
//			G_Enemy_Anim(_e, _frame, 3);
//			Enemy_Patterns(_e,  3);				//行動パターン 3:前進
//			if (_pb.F == true && y_range <= BOM_ST && x_range <= CHIP_SIZE) {//ボム発射フラグON & ボムの射程距離内にいる & ボムとのX軸の距離がチップサイズ(32)以内にある
//				_e->pat = 1;						//パターンの変更
//			}
//		}
//		if (_e->pat == 1) {
//			G_Enemy_Anim(_e, _frame, 3);
//			_e->center_y -= (float)_e->speed;		//Y軸の移動
//			if (_pb.F == false) {
//				_e->pat = 0;						//ボムのフラグが消えると停止パターンに戻る
//			}
//		}
//		break;
//		//停止し、ブラスターに反応してダッシュし、再び停止を繰り返す(10,000点)
//	case 8:
//		if (_e->pat == 0) {
//			if (_pb.F == true && y_range <= BOM_ST && x_range <= CHIP_SIZE) {	//ボム発射フラグON & ボムの射程距離内にいる & ボムとのX軸の距離がチップサイズ(32)以内にある
//				_e->pat = 1;
//				_e->speed *= speed_ratio;			//ダッシュする
//			}
//		}
//		if (_e->pat == 1) {
//			G_Enemy_Anim(_e, _frame, 3);
//			Enemy_Patterns(_e,  3);				//行動パターン 3:前進
//			if (_pb.F == false) {
//				_e->pat = 0;
//				_e->speed /= speed_ratio;			//速度を戻す
//			}
//		}
//		break;
//	}
//}
//
////===============================================================================================
////						ボザログラム[ログラムが4つくっついている敵]
////
//// 単体では何もしない。
//// 周囲のログラムはボザログラムが破壊されると連鎖して撃破される。連鎖撃破されたログラムの得点は入らない
////===============================================================================================
//void BOZALOGRAM() {	/*特にナシ*/ }
//
////===============================================================================================
////						ソル[ボムを当てるまで姿を見せない敵]
////
////ボムを当てるまでは見えない。当てた後は姿を表し、そこから更に撃破可能。高得点
//// ・pat 0:anim番号は固定。ボムがヒットしたらパターンを変更する
//// ・pat 1:姿を現す途中経過。アニメーションが完了するまでは無敵
//// ・pat 2:姿を現してからは特に何もしない
////===============================================================================================
//void SOL(ENEMY_ST* _e, int _frame){
//
//	int number = _e->number - 50;		//ナンバーを0〜12の間にする
//
//	if (_e->hit && _e->pat == 2) { _e->anim = 0; return; }		//パターンが2状態で撃破されたらanimを0にし、処理をここで終える
//
//	switch (_e->pat) {
//	case 0:
//		if (_e->hit == false) {
//			_e->anim = 3;							//アニメーションの固定(何も描かれていないanim番号)
//		}
//		else {
//			_e->anim = number * _e->anim_sum;		//アニメーションを初期値に戻す
//			_e->pat++;								//パターンを進める
//		}
//		break;
//	case 1:
//		_e->ac_count = 7;			//爆発エフェクトを発生させない
//		if (_frame % 9 == 0) {		//9フレームに1回anim番号を進める
//			_e->anim++;
//		}
//		if (_e->anim >= 31) {		//animが最後の番号に達したら
//			_e->pat++;				//パターンを進める
//			_e->hit = false;		//このタイミングで再度撃破できるようにhit判定を元に戻す
//		}
//		break;
//	case 2:
//		if (_e->hit == true) { /*特になし*/ }
//		break;
//	
//	}
//}
//
////===============================================================================================
////						ガルバーラ[大きいピラミッド]
////
////でかいが当たり判定はバーラと同じ大きさである。ちなみに「ガル」は大きいという意味らしい
//// ・撃破された爆発地点には独自の画像が使われる
////===============================================================================================
//void GARUBARRA(ENEMY_ST* _e) {
//	if (_e->hit) {
//		_e->anim = 21;
//	}
//}
//
////===============================================================================================
////						ガルデローダ[大きい固定砲台]
////
////でかいが当たり判定はデローダと同じ大きさである。ちなみに「ガル」は大きいという意味らしい
////他の砲台と違い、画面から完全にいなくなるまで射撃を続ける
//// ・一定間隔で射撃する
//// 
//// //===============================================================================================
//void GARUDEROTA(float px, float py, ENEMY_ST* _e, ENEMY_SHOT* _s, int _frame) {
//
//	int number = _e->number - 50;
//
//	//敵弾の発射が可能かの判定
//	bool shot_ok = true;				//trueなら弾の発射ができる
//	int shotnum = E_shotGetEmptyNum(*_s);		//フラグの立っていない敵弾を探す
//	if (shotnum == 99) { shot_ok = false; }	//sが99 -> 弾の上限が超えているため弾が発射できないようにする
//
//
//	//撃破されている場合は特定のアニメーション固定で処理を終了する
//	if (_e->hit) { _e->anim = 22; return; }
//
//	//アニメーションの進行
//	if (_frame % 10 == 0) {
//		_e->anim++;
//		REPEAT(_e->anim, 24, 27)
//	}
//	
//	//1/60の間隔で射撃をする
//	if (_frame % 60 == 0) {					
//		if (shot_ok) {
//			E_Shot_Create(_s, px, py, _e->center_x, _e->center_y, 0);		//自機に向かって弾を発射する
//		}
//
//	}
//}
//
////===============================================================================================
////						スペシャルフラッグ[Sと書かれた黄色い旗]
////
////1upアイテム。最初は完全に隠れて見えない。ボムを当てることで画面に現れる
//// ・画面上では視認できないが、照準器が当たり判定にあたると照準器が赤くなる
//// ・出現させた後はプレイヤーの当たり判定と重なることで取得となる
//// //===============================================================================================
//void SPECIALFLAG(RECT p_hitbox, RECT sight_hitbox,bool* lookon,ENEMY_ST* _e) {
//	//ボムを当てる前
//	if (_e->hit == false) {
//		if (Hit_box(sight_hitbox, _e->hitbox)) {	//SPフラッグが照準器に重なっているかの判定
//			*lookon = false;
//		}
//	}
//	//ボムを当てた後
//	else {
//		_e->ac_count = 100;
//		_e->anim = 2;
//		if (Hit_box(p_hitbox, _e->hitbox)) {		//自機と接触したら
//			state.life++;								//残機を増やす
//			_e->frame_in = false;					//画面から非表示にする
//		}
//	}
//}
//
////============================================================
////				ドモグラム専用の移動パターン
//// 
//// 周囲９チップ分を探索し、特定の値が見つかったらその方向へと進む
//// ・もし特定の値が見つからなかった場合はその向きのまま直進する
//// ・自分が移動する時、元居た場所の番号は -1 (null)となる
////============================================================
//
//void AroundSearch(ENEMY_ST* _e, MAP* _m, int pat)
//{
//	int dir_search = CHIP_SIZE + (CHIP_SIZE - (CHIP_SIZE * _e->speed));
//
//	switch (pat) {
//		/*裏マップの座標を参照して自分の周囲９マスを調べ、特定の数値の座標へと移動する*/
//	case 50:
//		if ((_e->ac_count % dir_search) == 0) {		//マップチップの大きさと同じ数値行動したら周囲を確認する
//			for (int r = -1; r <= 1; r++) {					//y軸(上下 ±1マス マップの横幅)
//				for (int r2 = -1; r2 <= 1; r2++) {			//x軸(左右 ±1マス)
//					int SeachMapChipNum = _m->backmap[_e->back_num].data[_e->back_coord + (r * MAP_W) + r2];	//周囲3×3マスの内の一つのChip番号を取り出す
//					if (SeachMapChipNum == 20) {		//裏マップにある特定の数値(今回は20)を検出したら
//
//						_e->move_y = r;						//上下どちらに移動するかを決める(-1で上、0でｙ軸移動なし、1で下へ移動) 
//						_e->move_x = r2;					//左右どちらに移動するかを決める(-1で左、0でx軸移動ナシ、1で右へ移動)
//
//						_m->backmap[_e->back_num].data[_e->back_coord] = -1;							//自分の元居た位置と
//						_m->backmap[_e->back_num].data[_e->back_coord + (r * MAP_W) + r2] = -1;			//移動先の数値を'-1'(設定なし)にする
//
//						//裏マップにおける自分の座標を移動させる
//						r = 1;										//外のループを抜けるために継続条件から外す
//						break;										//中のループから抜け出す
//					}
//					//フリップ(反転)
//					if (SeachMapChipNum == 21) {		//裏マップにある特定の数値(今回は20)を検出したら
//
//						_e->move_y = r * -1;						//上下どちらに移動するかを決める(-1で上、0でｙ軸移動なし、1で下へ移動) 
//						_e->move_x = r2 * -1;					//左右どちらに移動するかを決める(-1で左、0でx軸移動ナシ、1で右へ移動)			
//						break;										//中のループから抜け出す
//					}
//				}
//			}
//			_e->back_coord += (_e->move_y * MAP_W) + _e->move_x;
//		}
//
//		_e->center_x += _e->move_x * _e->speed;
//		_e->center_y += _e->move_y * _e->speed;
//		break;
//	case 51:
//
//		if (_e->ac_count % CHIP_SIZE == 0) {		//マップチップの大きさと同じ数値行動したら周囲を確認する
//			for (int r = -1; r <= 1; r++) {					//y軸(上下 ±1マス マップの横幅)
//				for (int r2 = -1; r2 <= 1; r2++) {			//x軸(左右 ±1マス)
//					if (_m->backmap[_e->back_num].data[_e->back_coord + (r * MAP_W) + r2] == 21) {		//裏マップにある特定の数値(今回は20)を検出したら
//
//						_m->backmap[_e->back_num].data[_e->back_coord] = -1;								//自分の元居た位置と
//						_m->backmap[_e->back_num].data[_e->back_coord + (r * MAP_W) + r2] = -1;			//移動先の数値を'0'(設定なし)にする
//
//						r = 1;										//外のループを抜けるために継続条件から外す
//						break;										//中のループから抜け出す
//					}
//				}
//			}
//		}
//
//		_e->center_x += _e->move_x;
//		_e->center_y += _e->move_y;
//		_e->back_coord += (_e->move_y * MAP_W) + _e->move_x;							//裏マップにおける自分の座標を移動させる
//		break;
//
//	}
//
//
//}
